/*
 * Chapter 5. Integer
 *
 * 보수(Complement)
 * 보수(Complement)는 어떤 수(기수)가 되기 위하여 보충하는 수를 의미
 * A + B = R 에서 A는 R에 대한 B의 보수 또는 B는 R에 대한 A의 보수라고 함.
 *
 * 2의 보수(2's Complement)
 * 2의 보수화 방식은 양의 정수를 1의 보수로 변경한 다음 1을 더함.
 * -> 2를 2의 보수로 변경하는 방법
 *
 *         0 0 0 0 0 0 1 0 -> 2
 *         ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ 반전
 *         1 1 1 1 1 1 0 1 -> -2(1의 보수)
 *       + 0 0 0 0 0 0 0 1 -> 1을 더함
 *       -----------------------------
 *         1 1 1 1 1 1 1 0 -> -2(2의 보수)
 *
 *
 *  현대의 모든 프로세서는 2의 보수화 방식을 사용
 *
 *
 *  2의 보수화 방식의 장점
 *
 *  - 최상휘 비트의 성질이 그대로 유지됨(0이면 양수, 1이면 음수)
 *  - 감산기가 필요없으므로 비용이 감소함
 *  - 0에 대한 중복 표현이 사라짐
 *  - 연산 시 자리 올림을 계산하지 않아도 됨
 *  - 가산기만을 이용하여 사칙 연산이 가능함(곱셈은 덧셈의 연속이고, 나눗셈은 뺄셈의 연속임)
 *
 *
 *
 */

#if 0
#include <stdio.h>

typedef struct {
    char a : 3;
    char b : 2;
    char c : 1;
    unsigned char d : 2;
} BIT;

int main() {
    BIT bit = { .a = 4,.b = 3,.c = 1,.d = 3 };

    printf("bit.a = %d\n", bit.a);
    printf("bit.b = %d\n", bit.b);
    printf("bit.c = %d\n", bit.c);
    printf("bit.d = %d\n", bit.d);

    return 0;
}
#endif
